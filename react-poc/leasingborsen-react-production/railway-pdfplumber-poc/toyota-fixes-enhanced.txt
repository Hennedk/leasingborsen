# Toyota Variant Extraction Fixes for Problematic Cases - Enhanced Version

import re
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TransmissionType(Enum):
    """Transmission type enumeration"""
    MANUAL = "manual"
    AUTOMATIC = "automatic"
    CVT = "cvt"
    UNKNOWN = "unknown"


class DrivetrainType(Enum):
    """Drivetrain type enumeration"""
    FWD = "FWD"
    AWD = "AWD"
    RWD = "RWD"
    UNKNOWN = "unknown"


@dataclass
class VariantPattern:
    """Data class for variant patterns"""
    name: str
    pattern: str
    description: str


class ToyotaVariantFixer:
    """Fix specific extraction and deduplication issues for Toyota variants"""
    
    DEFAULT_CONFIG_PATH = Path(__file__).parent / "toyota_patterns_config.json"
    
    def __init__(self, config_path: Optional[Path] = None):
        """Initialize with optional configuration file"""
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.config_path = config_path or self.DEFAULT_CONFIG_PATH
        
        # Load patterns
        if self.config_path.exists():
            self.patterns = self._load_patterns_from_config(self.config_path)
            self.logger.info(f"Loaded patterns from {self.config_path}")
        else:
            self.patterns = self._build_default_patterns()
            self.logger.info("Using default patterns")
        
        # Pre-compile patterns for performance
        self.compiled_patterns = self._compile_patterns(self.patterns)
        
        # Statistics tracking
        self.stats = {
            'aygo_x_fixes': 0,
            'bz4x_awd_fixes': 0,
            'yaris_cross_fixes': 0,
            'total_variants_processed': 0,
            'duplicates_removed': 0
        }
    
    def _load_patterns_from_config(self, config_path: Path) -> Dict[str, Dict[str, str]]:
        """Load patterns from configuration file"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            return config.get('patterns', {})
        except Exception as e:
            self.logger.error(f"Failed to load config from {config_path}: {e}")
            return self._build_default_patterns()
    
    def _compile_patterns(self, patterns: Dict[str, Dict[str, str]]) -> Dict[str, Dict[str, re.Pattern]]:
        """Pre-compile all patterns for better performance"""
        compiled = {}
        for category, pattern_dict in patterns.items():
            compiled[category] = {}
            for name, pattern in pattern_dict.items():
                try:
                    compiled[category][name] = re.compile(pattern, re.VERBOSE)
                except re.error as e:
                    self.logger.error(f"Failed to compile pattern {category}.{name}: {e}")
                    # Use a pattern that never matches as fallback
                    compiled[category][name] = re.compile(r'(?!.*)')
        return compiled
    
    def _build_default_patterns(self) -> Dict[str, Dict[str, str]]:
        """Build default patterns for extraction"""
        return {
            'aygo_x_manual_auto': self._build_aygo_x_patterns(),
            'bz4x_awd_variants': self._build_bz4x_awd_patterns(),
            'yaris_cross_missing': self._build_yaris_cross_patterns()
        }
    
    def _build_aygo_x_patterns(self) -> Dict[str, str]:
        """Build patterns to distinguish AYGO X manual vs automatic"""
        return {
            # Pattern 1: Manual transmission (no automatgear)
            'manual': r'''
                ^(Active|Pulse)\s+                    # Variant name
                (\d{1,2}\.\d{3})\s+                   # Monthly price (2.699)
                (\d{1,2}\.\d{3})\s+                   # First payment (4.999)
                (\d{2,3}\.\d{3})\s+                   # Minimum price
                (\d{2,3}\.\d{3})\s+                   # Total price
                ([\d,]+/\d+)\s+                       # Fuel consumption/CO2
                (\d{2}\.\d{3})\s+                     # Annual km
                (\d{3})                               # Tax
                (?!\s+automatgear)                    # NOT followed by automatgear
            ''',
            
            # Pattern 2: Automatic transmission (with automatgear)
            'automatic': r'''
                ^(Active|Pulse)\s+                    # Variant name
                (\d{1,2}\.\d{3})\s+                   # Monthly price (2.999)
                (\d{1,2}\.\d{3})\s+                   # First payment (4.999)
                (\d{2,3}\.\d{3})\s+                   # Minimum price
                (\d{2,3}\.\d{3})\s+                   # Total price
                ([\d,]+/\d+)\s+                       # Fuel consumption/CO2
                (\d{2}\.\d{3})\s+                     # Annual km
                (\d{3}).*?                            # Tax
                automatgear                           # Followed by automatgear
            '''
        }
    
    def _build_bz4x_awd_patterns(self) -> Dict[str, str]:
        """Build patterns to capture BZ4X AWD variants properly"""
        return {
            # Pattern for AWD section header
            'awd_section': r'73[,.]1\s*kWh,?\s*343\s*hk\s*AWD',
            
            # Pattern for variants under AWD section
            'awd_variants': r'''
                ^(Active|Executive|Executive\s+Panorama)\s+  # Variant
                (\d{1,2}\.\d{3})\s+                          # Monthly price
                (\d{1,2}\.\d{3})\s+                          # First payment
                (\d{2,3}\.\d{3})\s+                          # Minimum
                (\d{2,3}\.\d{3})\s+                          # Total
                (\d{3})\s+                                   # Consumption
                (\d{3})\s+                                   # Range
                ([\d,/.]+)\s+                                # Battery info
                (\d{2}\.\d{3})\s+                            # Annual km
                (\d{3})                                      # Tax
            ''',
            
            # Pattern for FWD variants (for comparison)
            'fwd_variants': r'''
                ^(Active|Executive|Executive\s+Panorama)\s+  # Variant
                (\d{1,2}\.\d{3})\s+                          # Monthly price
                (\d{1,2}\.\d{3})\s+                          # First payment
                (\d{2,3}\.\d{3})\s+                          # Minimum
                (\d{2,3}\.\d{3})\s+                          # Total
                (\d{3})\s+                                   # Consumption
                (\d{3})\s+                                   # Range
                ([\d,/.]+)\s+                                # Battery info
                (\d{2}\.\d{3})\s+                            # Annual km
                (\d{3})                                      # Tax
            '''
        }
    
    def _build_yaris_cross_patterns(self) -> Dict[str, str]:
        """Build patterns to find missing YARIS CROSS variants"""
        return {
            # High-power variants (130 hk)
            'high_power': r'''
                ^(Elegant|GR\s+Sport)\s+                     # High-end variants
                (\d{1,2}\.\d{3})\s+                          # Monthly price
                (\d+)\s+                                     # First payment (often 0)
                (\d{2,3}\.\d{3})\s+                          # Minimum
                (\d{2,3}\.\d{3})\s+                          # Total
                ([\d,]+/\d+)\s+                              # Fuel/CO2
                (\d{2}\.\d{3})\s+                            # Annual km
                (\d{3})                                      # Tax
            ''',
            
            # Standard variants (116 hk)
            'standard': r'''
                ^(Active|Active\s+Safety|Style\s+Comfort|Style\s+Safety)\s+  # Standard variants
                (\d{1,2}\.\d{3})\s+                          # Monthly price
                (\d+)\s+                                     # First payment
                (\d{2,3}\.\d{3})\s+                          # Minimum
                (\d{2,3}\.\d{3})\s+                          # Total
                ([\d,]+/\d+)\s+                              # Fuel/CO2
                (\d{2}\.\d{3})\s+                            # Annual km
                (\d{3})                                      # Tax
            '''
        }
    
    def extract_aygo_x_variants(self, text: str) -> List[Dict[str, Any]]:
        """Extract AYGO X variants with proper manual/automatic distinction"""
        variants = []
        self.logger.info("Extracting AYGO X variants")
        
        # Find AYGO X section
        aygo_section = self._find_model_section(text, "AYGO X")
        if not aygo_section:
            self.logger.warning("AYGO X section not found")
            return variants
        
        # Extract manual variants
        manual_pattern = self.compiled_patterns['aygo_x_manual_auto']['manual']
        for match in manual_pattern.finditer(aygo_section):
            try:
                variant = self._build_aygo_x_variant(match, transmission=TransmissionType.MANUAL)
                variants.append(variant)
                self.stats['aygo_x_fixes'] += 1
            except Exception as e:
                self.logger.error(f"Failed to build AYGO X manual variant: {e}")
        
        # Extract automatic variants
        auto_pattern = self.compiled_patterns['aygo_x_manual_auto']['automatic']
        for match in auto_pattern.finditer(aygo_section):
            try:
                variant = self._build_aygo_x_variant(match, transmission=TransmissionType.AUTOMATIC)
                variants.append(variant)
                self.stats['aygo_x_fixes'] += 1
            except Exception as e:
                self.logger.error(f"Failed to build AYGO X automatic variant: {e}")
        
        self.logger.info(f"Found {len(variants)} AYGO X variants")
        return variants
    
    def extract_bz4x_awd_variants(self, text: str) -> List[Dict[str, Any]]:
        """Extract BZ4X AWD variants that are being lost"""
        variants = []
        self.logger.info("Extracting BZ4X AWD variants")
        
        # Find BZ4X section
        bz4x_section = self._find_model_section(text, "BZ4X")
        if not bz4x_section:
            self.logger.warning("BZ4X section not found")
            return variants
        
        # Look for AWD section marker
        awd_section_pattern = self.compiled_patterns['bz4x_awd_variants']['awd_section']
        awd_match = awd_section_pattern.search(bz4x_section)
        
        if awd_match:
            # Find AWD section start
            awd_start = awd_match.end()
            awd_text = bz4x_section[awd_start:]
            
            # Extract AWD variants from this section
            awd_pattern = self.compiled_patterns['bz4x_awd_variants']['awd_variants']
            for match in awd_pattern.finditer(awd_text):
                try:
                    variant = self._build_bz4x_awd_variant(match)
                    variants.append(variant)
                    self.stats['bz4x_awd_fixes'] += 1
                except Exception as e:
                    self.logger.error(f"Failed to build BZ4X AWD variant: {e}")
        else:
            self.logger.warning("AWD section marker not found in BZ4X section")
        
        self.logger.info(f"Found {len(variants)} BZ4X AWD variants")
        return variants
    
    def extract_missing_yaris_cross_variants(self, text: str) -> List[Dict[str, Any]]:
        """Extract missing YARIS CROSS variants"""
        variants = []
        self.logger.info("Extracting YARIS CROSS variants")
        
        # Find YARIS CROSS section
        yaris_cross_section = self._find_model_section(text, "YARIS CROSS")
        if not yaris_cross_section:
            self.logger.warning("YARIS CROSS section not found")
            return variants
        
        # Extract high-power variants (Elegant, GR Sport)
        high_power_pattern = self.compiled_patterns['yaris_cross_missing']['high_power']
        for match in high_power_pattern.finditer(yaris_cross_section):
            try:
                variant = self._build_yaris_cross_variant(match, power_type='130hk')
                variants.append(variant)
                self.stats['yaris_cross_fixes'] += 1
            except Exception as e:
                self.logger.error(f"Failed to build YARIS CROSS high-power variant: {e}")
        
        # Extract standard variants if missing
        standard_pattern = self.compiled_patterns['yaris_cross_missing']['standard']
        for match in standard_pattern.finditer(yaris_cross_section):
            try:
                variant = self._build_yaris_cross_variant(match, power_type='116hk')
                variants.append(variant)
                self.stats['yaris_cross_fixes'] += 1
            except Exception as e:
                self.logger.error(f"Failed to build YARIS CROSS standard variant: {e}")
        
        self.logger.info(f"Found {len(variants)} YARIS CROSS variants")
        return variants
    
    def _find_model_section(self, text: str, model: str) -> Optional[str]:
        """Find the section of text for a specific model"""
        # Look for model header
        model_pattern = rf'^{re.escape(model)}\s*$'
        
        lines = text.split('\n')
        start_idx = None
        
        for i, line in enumerate(lines):
            if re.match(model_pattern, line.strip(), re.IGNORECASE):
                start_idx = i
                break
        
        if start_idx is None:
            return None
        
        # Find end of section (next model or end of text)
        end_idx = len(lines)
        model_keywords = ['YARIS', 'COROLLA', 'BZ4X', 'URBAN CRUISER', 'AYGO X', 'C-HR', 'RAV4']
        
        for i in range(start_idx + 1, len(lines)):
            line = lines[i].strip()
            # Check if this is a new model section
            if any(keyword in line.upper() for keyword in model_keywords):
                # Make sure it's not the same model
                if not re.match(model_pattern, line, re.IGNORECASE):
                    end_idx = i
                    break
        
        return '\n'.join(lines[start_idx:end_idx])
    
    def _safe_parse_price(self, price_str: str) -> int:
        """Safely parse price string to integer"""
        try:
            return int(price_str.replace('.', '').replace(',', ''))
        except (ValueError, AttributeError) as e:
            self.logger.warning(f"Failed to parse price '{price_str}': {e}")
            return 0
    
    def _build_aygo_x_variant(self, match: re.Match, transmission: TransmissionType) -> Dict[str, Any]:
        """Build AYGO X variant with proper transmission differentiation"""
        variant_name = match.group(1)
        monthly_price = self._safe_parse_price(match.group(2))
        first_payment = self._safe_parse_price(match.group(3))
        
        # Build engine specification with transmission
        if transmission == TransmissionType.AUTOMATIC:
            engine_spec = "1.0 benzin 72 hk automatgear"
            variant_id = f"aygo_x_{variant_name.lower()}_auto"
        else:
            engine_spec = "1.0 benzin 72 hk"
            variant_id = f"aygo_x_{variant_name.lower()}_manual"
        
        return {
            'id': variant_id,
            'make': 'Toyota',
            'model': 'AYGO X',
            'variant': f"{variant_name} {engine_spec}",
            'engine_specification': engine_spec,
            'monthly_price': monthly_price,
            'first_payment': first_payment,
            'transmission_type': transmission.value,
            'source': 'aygo_x_fix',
            'extraction_confidence': 0.95
        }
    
    def _build_bz4x_awd_variant(self, match: re.Match) -> Dict[str, Any]:
        """Build BZ4X AWD variant with proper AWD designation"""
        variant_name = match.group(1)
        monthly_price = self._safe_parse_price(match.group(2))
        first_payment = self._safe_parse_price(match.group(3))
        
        # Build engine specification for AWD
        engine_spec = "73.1 kWh, 343 hk AWD"
        variant_id = f"bz4x_{variant_name.lower().replace(' ', '_')}_343hp_awd"
        
        return {
            'id': variant_id,
            'make': 'Toyota',
            'model': 'BZ4X',
            'variant': f"{variant_name} {engine_spec}",
            'engine_specification': engine_spec,
            'monthly_price': monthly_price,
            'first_payment': first_payment,
            'drivetrain_type': DrivetrainType.AWD.value,
            'powertrain_category': 'electric',
            'source': 'bz4x_awd_fix',
            'extraction_confidence': 0.95
        }
    
    def _build_yaris_cross_variant(self, match: re.Match, power_type: str) -> Dict[str, Any]:
        """Build YARIS CROSS variant with proper power specification"""
        variant_name = match.group(1)
        monthly_price = self._safe_parse_price(match.group(2))
        first_payment_str = match.group(3)
        first_payment = self._safe_parse_price(first_payment_str) if first_payment_str != '0' else 0
        
        # Build engine specification based on power type
        if power_type == '130hk':
            engine_spec = "1.5 Hybrid 130 hk aut."
            power_suffix = "130hp"
        else:
            engine_spec = "1.5 Hybrid 116 hk aut."
            power_suffix = "116hp"
        
        variant_id = f"yaris_cross_{variant_name.lower().replace(' ', '_')}_{power_suffix}"
        
        return {
            'id': variant_id,
            'make': 'Toyota',
            'model': 'YARIS CROSS',
            'variant': f"{variant_name} {engine_spec}",
            'engine_specification': engine_spec,
            'monthly_price': monthly_price,
            'first_payment': first_payment if first_payment > 0 else None,
            'powertrain_category': 'hybrid',
            'source': 'yaris_cross_fix',
            'extraction_confidence': 0.95
        }
    
    def apply_fixes(self, extracted_variants: List[Dict[str, Any]], pdf_text: str) -> List[Dict[str, Any]]:
        """Apply all fixes to the extracted variants"""
        self.logger.info("🔧 Applying Toyota variant extraction fixes...")
        self.stats['total_variants_processed'] = len(extracted_variants)
        
        # Extract problematic variants using targeted patterns
        aygo_x_fixes = self.extract_aygo_x_variants(pdf_text)
        bz4x_awd_fixes = self.extract_bz4x_awd_variants(pdf_text)
        yaris_cross_fixes = self.extract_missing_yaris_cross_variants(pdf_text)
        
        self.logger.info(
            f"🔧 Found fixes: {len(aygo_x_fixes)} AYGO X, "
            f"{len(bz4x_awd_fixes)} BZ4X AWD, {len(yaris_cross_fixes)} YARIS CROSS"
        )
        
        # Remove existing problematic variants from original list
        cleaned_variants = self._remove_problematic_variants(extracted_variants)
        
        # Add fixed variants
        all_variants = cleaned_variants + aygo_x_fixes + bz4x_awd_fixes + yaris_cross_fixes
        
        # Final deduplication using improved logic
        final_variants = self._smart_deduplication(all_variants)
        
        self.logger.info(f"🔧 Final result: {len(final_variants)} unique variants after fixes")
        self._log_statistics()
        
        return final_variants
    
    def _remove_problematic_variants(self, variants: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Remove variants that will be replaced by fixes"""
        cleaned = []
        
        for variant in variants:
            model = variant.get('model', '')
            variant_name = variant.get('variant', '')
            
            # Skip AYGO X variants that will be fixed
            if model == 'AYGO X' and any(v in variant_name for v in ['Active', 'Pulse']):
                self.logger.debug(f"Removing problematic AYGO X variant: {variant_name}")
                continue
            
            # Skip BZ4X AWD variants that will be fixed
            if model == 'BZ4X' and 'AWD' in variant.get('engine_specification', ''):
                self.logger.debug(f"Removing problematic BZ4X AWD variant: {variant_name}")
                continue
            
            # Skip YARIS CROSS high-power variants that will be fixed
            if model == 'YARIS CROSS' and any(v in variant_name for v in ['Elegant', 'GR Sport']):
                self.logger.debug(f"Removing problematic YARIS CROSS variant: {variant_name}")
                continue
            
            cleaned.append(variant)
        
        return cleaned
    
    def _smart_deduplication(self, variants: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Smart deduplication that preserves important differences"""
        seen_ids = set()
        unique_variants = []
        
        for variant in variants:
            variant_id = variant.get('id')
            
            if not variant_id:
                # Generate ID if missing
                variant_id = self._generate_fallback_id(variant)
                variant['id'] = variant_id
            
            if variant_id not in seen_ids:
                seen_ids.add(variant_id)
                unique_variants.append(variant)
            else:
                self.logger.debug(f"🔍 Duplicate removed: {variant_id}")
                self.stats['duplicates_removed'] += 1
        
        return unique_variants
    
    def _generate_fallback_id(self, variant: Dict[str, Any]) -> str:
        """Generate fallback ID for variants without one"""
        model = variant.get('model', '').lower().replace(' ', '_')
        variant_name = variant.get('variant', '').lower().replace(' ', '_')
        price = variant.get('monthly_price', 0)
        
        # Include transmission/drivetrain info if available
        transmission = variant.get('transmission_type', '')
        drivetrain = variant.get('drivetrain_type', '')
        
        id_parts = [model, variant_name, str(price)]
        if transmission:
            id_parts.append(transmission)
        if drivetrain:
            id_parts.append(drivetrain)
        
        return '_'.join(id_parts)
    
    def _log_statistics(self):
        """Log extraction statistics"""
        self.logger.info("📊 Extraction Statistics:")
        self.logger.info(f"   Total variants processed: {self.stats['total_variants_processed']}")
        self.logger.info(f"   AYGO X fixes applied: {self.stats['aygo_x_fixes']}")
        self.logger.info(f"   BZ4X AWD fixes applied: {self.stats['bz4x_awd_fixes']}")
        self.logger.info(f"   YARIS CROSS fixes applied: {self.stats['yaris_cross_fixes']}")
        self.logger.info(f"   Duplicates removed: {self.stats['duplicates_removed']}")
    
    def export_patterns_to_config(self, output_path: Path):
        """Export current patterns to a configuration file"""
        config = {
            'version': '1.0',
            'patterns': self.patterns,
            'description': 'Toyota variant extraction patterns configuration'
        }
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"Exported patterns to {output_path}")
        except Exception as e:
            self.logger.error(f"Failed to export patterns: {e}")


# Main function with error handling
def fix_toyota_extraction(extracted_variants: List[Dict[str, Any]], pdf_text: str, 
                         config_path: Optional[Path] = None) -> List[Dict[str, Any]]:
    """Main function to fix Toyota variant extraction issues"""
    try:
        fixer = ToyotaVariantFixer(config_path)
        return fixer.apply_fixes(extracted_variants, pdf_text)
    except Exception as e:
        logger.error(f"Failed to apply Toyota extraction fixes: {e}")
        # Return original variants if fixes fail
        return extracted_variants


# Enhanced test functions
def test_aygo_x_pattern():
    """Test AYGO X manual vs automatic detection with validation"""
    test_text = """
    AYGO X
    Active 2.699 4.999 37.387 102.163 20,83/110 15.000 590
    Pulse 3.049 4.999 41.587 114.763 20,83/110 15.000 590
    Active 2.999 4.999 40.987 112.963 20/113 15.000 590 automatgear
    Pulse 3.449 4.999 46.387 129.163 20/113 15.000 590 automatgear
    """
    
    fixer = ToyotaVariantFixer()
    variants = fixer.extract_aygo_x_variants(test_text)
    
    # Validation
    expected_variants = {
        'manual': ['Active', 'Pulse'],
        'automatic': ['Active', 'Pulse']
    }
    
    manual_variants = [v for v in variants if v['transmission_type'] == 'manual']
    auto_variants = [v for v in variants if v['transmission_type'] == 'automatic']
    
    manual_names = [v['variant'].split()[0] for v in manual_variants]
    auto_names = [v['variant'].split()[0] for v in auto_variants]
    
    assert set(manual_names) == set(expected_variants['manual']), \
        f"Manual variants mismatch. Expected: {expected_variants['manual']}, Got: {manual_names}"
    
    assert set(auto_names) == set(expected_variants['automatic']), \
        f"Automatic variants mismatch. Expected: {expected_variants['automatic']}, Got: {auto_names}"
    
    print("✅ AYGO X pattern test passed!")
    for variant in variants:
        print(f"   {variant['id']}: {variant['variant']} - {variant['monthly_price']} DKK")


def test_bz4x_awd_pattern():
    """Test BZ4X AWD variant detection with validation"""
    test_text = """
    BZ4X
    73,1 kWh, 343 hk AWD
    Active 4.799 9.999 67.587 182.763 142 516 73,1/69 15.000 420
    Executive 5.299 9.999 73.587 200.763 144 506 73,1/69 15.000 420
    Executive Panorama 5.699 9.999 78.387 215.163 151 511 73,1/69 15.000 420
    """
    
    fixer = ToyotaVariantFixer()
    variants = fixer.extract_bz4x_awd_variants(test_text)
    
    # Validation
    expected_awd_variants = ['Active', 'Executive', 'Executive Panorama']
    found_names = [v['variant'].split()[0] for v in variants]
    
    assert len(variants) == 3, f"Expected 3 AWD variants, got {len(variants)}"
    assert all(v['drivetrain_type'] == 'AWD' for v in variants), "All variants should be AWD"
    
    print("✅ BZ4X AWD pattern test passed!")
    for variant in variants:
        print(f"   {variant['id']}: {variant['variant']} - {variant['monthly_price']} DKK")


def run_all_tests():
    """Run all pattern tests"""
    print("🧪 Running Toyota variant extraction tests...")
    
    try:
        test_aygo_x_pattern()
        test_bz4x_awd_pattern()
        print("\n✅ All tests passed!")
    except AssertionError as e:
        print(f"\n❌ Test failed: {e}")
        raise


if __name__ == "__main__":
    # Run tests
    run_all_tests()